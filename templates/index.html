<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSRS Population Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        @font-face {
            font-family: 'RuneScape';
            src: url('https://raw.githubusercontent.com/runelite/runelite/master/runelite-client/src/main/resources/net/runelite/client/ui/runescape.ttf');
        }
        body {
            font-family: 'RuneScape', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1b1b1b;
            background-image: repeating-linear-gradient(45deg, #2b2b2b 0, #2b2b2b 1px, #1b1b1b 0, #1b1b1b 50%);
            color: #ffff00;
            text-shadow: 1px 1px 0 #000;
            text-align: center;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .card {
            background-color: #5b4a3c;
            padding: 20px;
            border: 3px solid #383023;
            border-radius: 4px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5), 2px 2px 5px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            color: #ffff00;
        }
        h1 { 
            margin-top: 0; 
            color: #ff981f;
            text-shadow: 2px 2px 0 #000;
            font-size: 2.5em;
        }
        .big-number {
            font-size: 3em;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 2px 2px 0 #000;
        }
        .timestamp { color: #d4d4d4; font-size: 0.9em; text-shadow: 1px 1px 0 #000; }
        canvas { max-height: 400px; }
        .site-footer {
            margin-top: 18px;
            font-size: 0.9em;
            color: #999;
            text-align: center;
        }
        .site-footer a {
            color: #90c040;
            text-decoration: none;
        }
        .site-footer a:hover {
            color: #ffffff;
            text-decoration: underline;
        }
        
        /* GitHub Link Tooltip */
        .github-link {
            position: relative;
            display: inline-block;
        }
        .github-link .tooltip {
            display: none;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%; /* Show above */
            margin-bottom: 8px;
            background: #5b4a3c;
            color: #ffff00;
            padding: 6px 8px;
            border: 2px solid #383023;
            white-space: nowrap;
            font-size: 0.9em;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            z-index: 30;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        .github-link:hover .tooltip {
            display: block;
        }

        /* OSRS Controls */
        button {
            background: #5b4a3c;
            color: #ffff00;
            border: 2px solid #383023;
            padding: 5px 10px;
            font-family: 'RuneScape', sans-serif;
            cursor: pointer;
            box-shadow: inset 1px 1px 0 rgba(255,255,255,0.1);
            text-shadow: 1px 1px 0 #000;
        }
        button:hover {
            background: #6d5a48;
            color: #ffffff;
        }
        select, input {
            background: #2b231a;
            color: #ffff00;
            border: 1px solid #5b4a3c;
            padding: 4px;
            font-family: 'RuneScape', sans-serif;
        }
        
        /* Override inline styles for labels */
        label[style*="color:#bdbdbd"] {
            color: #ff981f !important;
            text-shadow: 1px 1px 0 #000;
        }
        /* Also update the spinner and about text */
        #loadingSpinner, #about-app, #about-app div {
            color: #d4d4d4 !important;
            text-shadow: 1px 1px 0 #000;
        }
        /* Tooltip for granularity info */
        .info {
            position: relative;
            display: inline-block;
            vertical-align: middle;
            margin-left: 6px;
        }
        .info-icon {
            background: #383023;
            border-radius: 50%;
            padding: 2px 6px;
            border: 1px solid #5b4a3c;
            color: #ffff00;
            font-weight: 600;
            font-size: 0.85em;
            line-height: 1;
            cursor: help;
        }
        .info .tooltip {
            display: none;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: calc(100% + 8px);
            background: #5b4a3c;
            color: #ffff00;
            padding: 6px 8px;
            border: 2px solid #383023;
            border-radius: 0;
            white-space: nowrap;
            font-size: 0.85em;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            z-index: 30;
            text-shadow: 1px 1px 0 #000;
        }
        .info:hover .tooltip {
            display: block;
        }
        /* Easter Egg: Connection Lost */
        #connection-lost {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: #000;
            border: 2px solid #ffffff;
            padding: 10px 15px;
            z-index: 9999;
            font-family: 'RuneScape', sans-serif;
            box-shadow: 2px 2px 0px #000;
            text-align: center;
            width: 250px;
        }
        #connection-lost .title {
            color: #ffffff;
            font-size: 1.2em;
            margin-bottom: 4px;
        }
        #connection-lost .message {
            color: #ffffff;
            font-size: 1em;
        }
        /* Easter Egg: Gnome Child */
        #gnome-child {
            position: fixed;
            bottom: -150px;
            right: 20px;
            width: 100px;
            transition: bottom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 9998;
            pointer-events: none;
        }
        #gnome-child.peeking {
            bottom: 0;
        }
        /* Easter Egg: Dragon Scimitar Cursor Toggle */
        body.dragon-cursor, body.dragon-cursor * {
            cursor: url('https://oldschool.runescape.wiki/images/Dragon_scimitar.png?36084'), auto !important;
        }
        #scimitar-toggle {
            width: 32px;
            height: 32px;
            cursor: pointer;
            vertical-align: middle;
            margin-left: 10px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        #scimitar-toggle:hover {
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="connection-lost">
        <div class="title">Connection lost</div>
        <div class="message">Please wait - attempting to reestablish</div>
    </div>

    <!-- Easter Egg: Gnome Child -->
    <img id="gnome-child" src="https://oldschool.runescape.wiki/images/Gnome_child_chathead.png?c099b" alt="Gnome Child">

    <div class="container">
        <div class="card">
            <h1>OSRS Players Online</h1>
            <div id="player-count" class="big-number">Loading...</div>
            <div id="player-breakdown" style="font-size: 1.1em; color: #d4d4d4; margin-bottom: 8px; display: none;">
                <span style="color: #ffff00;">Members: <span id="members-count">...</span></span>
                <span style="margin: 0 10px;">|</span>
                <span style="color: #aaaaaa;">F2P: <span id="f2p-count">...</span></span>
            </div>
            <div id="last-updated" class="timestamp">Wait a moment...</div>
        </div>

        <div class="card">
            <!-- New Filters Row -->
            <div style="display:flex; flex-wrap:wrap; gap:12px; justify-content:center; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom: 1px solid #383023;">
                <label style="font-size:0.9em; color:#bdbdbd;">World:
                    <select id="worldSelect">
                        <option value="">All Worlds</option>
                    </select>
                </label>
                <label style="font-size:0.9em; color:#bdbdbd;">Location:
                    <select id="locationSelect">
                        <option value="">All Locations</option>
                    </select>
                </label>
                <label style="font-size:0.9em; color:#bdbdbd;">Type:
                    <select id="f2pSelect">
                        <option value="">All Types</option>
                        <option value="1">Free-to-Play</option>
                        <option value="0">Members</option>
                    </select>
                </label>
                <label style="font-size:0.9em; color:#bdbdbd; border-left: 1px solid #5b4a3c; padding-left: 12px; margin-left: 4px;">Compare:
                    <select id="compareSelect" style="background:#383023; border-color:#ff981f;">
                        <option value="none">None</option>
                        <option value="type">F2P vs Members</option>
                        <option value="location">Regions</option>
                        <option value="worlds">All Worlds</option>
                    </select>
                </label>
            </div>

            <div style="display:flex; flex-wrap:wrap; gap:8px; justify-content:center; align-items:center; margin-bottom:12px;">
                <label style="font-size:0.9em; color:#bdbdbd;">Granularity:
                    <select id="granularitySelect">
                        <option value="5m">5 min</option>
                        <option value="15m">15 min</option>
                        <option value="30m">30 min</option>
                        <option value="hour" selected>Hour</option>
                        <option value="day">Day</option>
                        <option value="week">Week</option>
                        <option value="month">Month</option>
                    </select>
                </label>
                <span id="granularityInfo" class="info" style="display:inline-block;" role="note">
                    <span class="info-icon" aria-hidden="true">ℹ</span>
                    <span class="tooltip" role="tooltip">Minute options disabled for ranges > 30 days</span>
                </span>
                <label style="font-size:0.9em; color:#bdbdbd;">Aggregation:
                    <select id="aggregationSelect">
                        <option value="max" selected>Peak</option>
                        <option value="avg">Average</option>
                    </select>
                </label>


                <div style="display:flex; gap:8px; align-items:center;">
                    <label style="font-size:0.9em; color:#bdbdbd;">Start:
                        <input id="startInput" type="datetime-local">
                    </label>
                    <label style="font-size:0.9em; color:#bdbdbd;">End:
                        <input id="endInput" type="datetime-local">
                    </label>
                </div>

                <button id="applyRangeBtn">Update</button>
                <button id="resetZoomBtn">Reset Zoom</button>

                <div style="display:flex; gap:6px; margin-left:8px; align-items:center;">
                    <label style="font-size:0.9em; color:#bdbdbd;">Range:
                        <select id="presetSelect">
                            <option value="custom" disabled hidden>Custom</option>
                            <option value="3h">Last 3h</option>
                            <option value="6h">Last 6h</option>
                            <option value="12h">Last 12h</option>
                            <option value="24h">Last 24h</option>
                            <option value="7d" selected>Last 7d</option>
                            <option value="30d">Last 30d</option>
                            <option value="6m">Last 6m</option>
                            <option value="1y">Last 1y</option>
                            <option value="5y">Last 5y</option>
                            <option value="10y">Last 10y</option>
                        </select>
                    </label>
                </div>
                <div id="loadingSpinner" style="display:none; margin-left:8px; color:#bdbdbd; font-size:0.9em;">Loading…</div>
            </div>

            <canvas id="populationChart"></canvas>
            <div id="chartError" class="timestamp" style="margin-top:8px; color:#ff6b6b; display:none;"></div>
            <div id="chart-timezone" class="timestamp" style="margin-top:8px;"></div>
            <div id="about-app" style="margin-top:12px; text-align:left; color:#bdbdbd; font-size:0.95em;">
                <button id="about-toggle" style="background:#232323; color:#ff9800; border:none; padding:6px 12px; border-radius:6px; cursor:pointer; font-size:1em;">More about this site</button>
                <div id="about-content" style="display:none; margin-top:10px;">
                    <strong>About this chart:</strong>
                    <div style="margin-top:6px;">This chart shows the number of players online. Use the controls above to change the date range and granularity. For large ranges the backend should return aggregated data for best performance.</div>
                    <div style="margin-top:8px;">How the bot works: a small python script periodically checks the Old School RuneScape homepage, extracts the reported online player count, and stores timestamped samples in the database. It runs at regular intervals (every 5 minutes by default).</div>
                    <div style="margin-top:8px;">Historical data (older than Dec 2, 2025) was sourced from <a href="https://www.misplaceditems.com/rs_tools/graph" target="_blank" rel="noopener noreferrer">misplaceditems.com — RS Tools (graph)</a> as well as <a href="https://playercount.dev/" target="_blank" rel="noopener noreferrer">playercount.dev</a>. That historical dataset is coarser: its timestamps and sample intervals are not as fine-grained as the samples collected by this bot, so recent data (collected by the bot) will appear with higher resolution than the imported history.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = '';

        // Collapsible About section
        document.addEventListener('DOMContentLoaded', function() {
            const toggleBtn = document.getElementById('about-toggle');
            const aboutContent = document.getElementById('about-content');
            let collapsed = true;
            toggleBtn.addEventListener('click', function() {
                collapsed = !collapsed;
                aboutContent.style.display = collapsed ? 'none' : 'block';
                toggleBtn.textContent = collapsed ? 'More about this site' : 'Less about this site';
            });
        });

        // Globals
        let populationChart = null;
        let rawHistory = []; // cache of last fetched raw points
        let globalMetadata = { locations: [], worlds: [] }; // Store metadata for comparison logic

        // Utility: format JS Date -> ISO used by datetime-local (without seconds)
        function toLocalInputISO(date) {
            const pad = n => String(n).padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
        }

        // Fetch metadata for filters
        async function fetchMetadata() {
            try {
                const response = await fetch(`${API_BASE}/api/metadata`);
                const data = await response.json();
                globalMetadata = data; // Save for later use
                
                // Populate Worlds
                const worldSelect = document.getElementById('worldSelect');
                data.worlds.forEach(w => {
                    const opt = document.createElement('option');
                    opt.value = w;
                    opt.textContent = `World ${parseInt(w) + 300}`;
                    worldSelect.appendChild(opt);
                });

                // Populate Locations
                const locSelect = document.getElementById('locationSelect');
                data.locations.forEach(loc => {
                    const opt = document.createElement('option');
                    opt.value = loc.id;
                    opt.textContent = loc.name;
                    locSelect.appendChild(opt);
                });

                // Activities are available in data.activities if we want to add them later
            } catch (error) {
                console.error('Error fetching metadata:', error);
            }
        }

        // Fetch latest player count
        async function fetchLatest() {
            try {
                const response = await fetch(`${API_BASE}/api/latest`);
                const data = await response.json();
                document.getElementById('player-count').innerText = data.count.toLocaleString();
                
                // Update breakdown if available
                if (data.f2p_count !== undefined && data.members_count !== undefined) {
                    document.getElementById('f2p-count').innerText = data.f2p_count.toLocaleString();
                    document.getElementById('members-count').innerText = data.members_count.toLocaleString();
                    document.getElementById('player-breakdown').style.display = 'block';
                }

                // Parse the timestamp returned by the API (UTC ISO 8601) and
                // display it in the viewer's local timezone.
                try {
                    const lastDate = new Date(data.timestamp);
                    const lastUpdatedStr = lastDate.toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' });
                    document.getElementById('last-updated').innerText = `Last updated: ${lastUpdatedStr}`;
                } catch (e) {
                    // Fallback to raw timestamp if parsing fails
                    // Format the timestamp in the user's local timezone
                try {
                    const ts = data.timestamp;
                    if (ts) {
                        const d = new Date(ts);
                        const formatted = d.toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' });
                        document.getElementById('last-updated').innerText = `Last updated: ${formatted}`;
                    } else {
                        document.getElementById('last-updated').innerText = `Last updated: ${data.timestamp}`;
                    }
                } catch (e) {
                    document.getElementById('last-updated').innerText = `Last updated: ${data.timestamp}`;
                }
                }
            } catch (error) {
                console.error('Error fetching latest:', error);
                document.getElementById('player-count').innerText = "Offline";
            }
        }

        // Fetch history from API with optional start/end (ISO) and unit/step for server-side aggregation
        async function fetchHistory({start=null, end=null, unit=null, step=null, limit=null, agg=null, world_id=null, location_id=null, is_f2p=null} = {}) {
            try {
                const params = new URLSearchParams();
                if (start) params.set('start', start);
                if (end) params.set('end', end);
                if (unit) params.set('unit', unit);
                if (step) params.set('step', step);
                if (limit) params.set('limit', limit);
                if (agg) params.set('agg', agg);
                
                if (world_id) params.set('world_id', world_id);
                if (location_id) params.set('location_id', location_id);
                if (is_f2p !== null && is_f2p !== "") params.set('is_f2p', is_f2p);

                const response = await fetch(`${API_BASE}/api/history?${params.toString()}`);
                const contentType = response.headers.get('content-type') || '';
                // If server returned non-OK (e.g., 400), try to show the server message
                if (!response.ok) {
                    if (contentType.includes('application/json')) {
                        const err = await response.json();
                        throw new Error(err.error || err.message || `Server responded ${response.status}`);
                    } else {
                        const txt = await response.text();
                        throw new Error(txt || `Server responded ${response.status}`);
                    }
                }
                const data = await response.json();
                // Expecting [{timestamp: ISO, count: number}, ...]
                rawHistory = data;
                return data;
            } catch (err) {
                console.error('Error fetching history:', err);
                throw err;
            }
        }

        function buildChart(datasets, granularityInfo) {
            const ctx = document.getElementById('populationChart').getContext('2d');
            const viewerTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Local';
            document.getElementById('chart-timezone').innerText = `Times shown in: ${viewerTimeZone}`;

            // If we receive a single array of points (legacy call), wrap it
            if (Array.isArray(datasets) && datasets.length > 0 && datasets[0].timestamp) {
                datasets = [{
                    label: 'Online Players',
                    data: datasets.map(p => ({ x: new Date(p.timestamp), y: p.count })),
                    borderColor: '#ffff00',
                    backgroundColor: 'rgba(255, 255, 0, 0.1)'
                }];
            }

            // Calculate global peak across all datasets
            let peak = null;
            let peakTime = null;
            let peakValue = -1;

            datasets.forEach(ds => {
                if (ds.data.length > 0) {
                    const localPeak = ds.data.reduce((max, p) => p.y > max.y ? p : max, ds.data[0]);
                    if (localPeak.y > peakValue) {
                        peakValue = localPeak.y;
                        peak = localPeak;
                        peakTime = localPeak.x.getTime();
                    }
                }
            });

            // Chart.js config with annotation for peak
            const cfg = {
                type: 'line',
                data: {
                    datasets: datasets.map(ds => ({
                        label: ds.label,
                        data: ds.data,
                        borderColor: ds.borderColor,
                        backgroundColor: ds.backgroundColor || 'rgba(0,0,0,0)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: !!ds.backgroundColor, // Only fill if background color provided
                        tension: 0.25
                    }))
                },
                options: {
                    responsive: true,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        decimation: { enabled: true, algorithm: 'lttb', samples: 1000 },
                        zoom: {
                            pan: { enabled: true, mode: 'x' },
                            zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
                        },
                        annotation: {
                            annotations: peak ? {
                                peakLine: {
                                    type: 'line',
                                    xMin: peakTime,
                                    xMax: peakTime,
                                    borderColor: 'rgba(255, 0, 0, 0.8)', // Red for peak
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: `Peak: ${peakValue.toLocaleString()}`,
                                        position: '20%',
                                        backgroundColor: 'rgba(255, 0, 0, 0.8)',
                                        color: 'white',
                                        font: {
                                            size: 12,
                                            family: 'RuneScape'
                                        }
                                    }
                                }
                            } : {}
                        },
                        tooltip: {
                            backgroundColor: '#5b4a3c',
                            titleColor: '#ff981f',
                            bodyColor: '#ffff00',
                            borderColor: '#383023',
                            borderWidth: 2,
                            titleFont: { family: 'RuneScape' },
                            bodyFont: { family: 'RuneScape' },
                            callbacks: {
                                title: function(context) {
                                    if (!context.length) return '';
                                    const d = context[0].parsed.x;
                                    return new Date(d).toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', timeZoneName: 'short' });
                                },
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toLocaleString()}`;
                                }
                            }
                        },
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                tooltipFormat: 'DD T',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm',
                                    day: 'MMM d',
                                    week: 'MMM d',
                                    month: 'MMM yyyy'
                                }
                            },
                            grid: { color: '#4e453a' },
                            ticks: { color: '#d4d4d4', font: { family: 'RuneScape' } }
                        },
                        y: { 
                            beginAtZero: true, 
                            grid: { color: '#4e453a' },
                            ticks: { color: '#d4d4d4', font: { family: 'RuneScape' } }
                        }
                    }
                }
            };

            if (populationChart) {
                populationChart.destroy();
            }
            populationChart = new Chart(ctx, cfg);
        }

        // Small helpers to show/hide errors and to enable/disable controls while fetching
        function showChartError(msg) {
            const el = document.getElementById('chartError');
            if (!el) return;
            if (msg) {
                el.innerText = msg;
                el.style.display = 'block';
            } else {
                el.innerText = '';
                el.style.display = 'none';
            }
        }

        function setControlsEnabled(enabled) {
            const ids = ['applyRangeBtn','resetZoomBtn','granularitySelect','aggregationSelect','startInput','endInput','presetSelect', 'worldSelect', 'locationSelect', 'f2pSelect', 'compareSelect'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.disabled = !enabled;
            });
        }

        // Simple spinner helpers
        function showSpinner() {
            const s = document.getElementById('loadingSpinner');
            if (s) s.style.display = 'inline-block';
        }
        function hideSpinner() {
            const s = document.getElementById('loadingSpinner');
            if (s) s.style.display = 'none';
        }

        // Disable minute granularity options when selected range > 1 day
        function updateGranularityAvailability() {
            const startVal = document.getElementById('startInput').value;
            const endVal = document.getElementById('endInput').value;
            const select = document.getElementById('granularitySelect');
            if (!select) return;

            // If both dates are present, compute duration in ms. If not, assume last-24h (allowed)
                const infoEl = document.getElementById('granularityInfo');
                if (startVal && endVal) {
                const startDt = new Date(startVal);
                const endDt = new Date(endVal);
                const durationMs = endDt - startDt;
                const oneDayMs = 30 * 24 * 60 * 60 * 1000;
                const disableMinutes = durationMs > oneDayMs;

                // iterate options and disable those ending with 'm'
                Array.from(select.options).forEach(opt => {
                    if (opt.value.endsWith('m')) opt.disabled = disableMinutes;
                });

                // If current selection is a minute option and now disabled, pick 'hour'
                if (select.value.endsWith('m') && select.options[select.selectedIndex].disabled) {
                    select.value = 'hour';
                }
                    // Update tooltip text when minute options are disabled/enabled
                    // Tooltip text is static and does not change
            } else {
                // No full range provided: enable minute options
                Array.from(select.options).forEach(opt => { if (opt.value.endsWith('m')) opt.disabled = false; });
                    // Tooltip text is static and does not change
            }
        }

        // Update chart using inputs (gracefully handle 400 responses from server)
        async function updateFromInputs() {
            const gran = document.getElementById('granularitySelect').value;
            const agg = document.getElementById('aggregationSelect').value;
            const startVal = document.getElementById('startInput').value;
            const endVal = document.getElementById('endInput').value;
            
            const worldId = document.getElementById('worldSelect').value;
            const locationId = document.getElementById('locationSelect').value;
            const isF2p = document.getElementById('f2pSelect').value;
            const compareMode = document.getElementById('compareSelect').value;

            const startISO = startVal ? new Date(startVal).toISOString() : null;
            const endISO = endVal ? new Date(endVal).toISOString() : null;

            // Map granularity string to Chart.js unit + optional step (for minute intervals)
            let unit = gran;
            let step = null;
            if (gran.endsWith('m')) {
                unit = 'minute';
                step = parseInt(gran.slice(0, -1), 10);
            }

            setControlsEnabled(false);
            showChartError('');
            showSpinner();
            
            try {
                let datasets = [];
                const colors = ['#ffff00', '#00ff00', '#00ffff', '#ff00ff', '#ff981f', '#ff0000', '#ffffff', '#aaaaaa'];

                if (compareMode === 'none') {
                    // Standard single series fetch
                    const history = await fetchHistory({ 
                        start: startISO, 
                        end: endISO, 
                        unit: unit, 
                        step: step, 
                        agg: agg,
                        world_id: worldId,
                        location_id: locationId,
                        is_f2p: isF2p
                    });
                    
                    datasets = [{
                        label: 'Online Players',
                        data: history.map(p => ({ x: new Date(p.timestamp), y: p.count })),
                        borderColor: '#ffff00',
                        backgroundColor: 'rgba(255, 255, 0, 0.1)'
                    }];
                } else if (compareMode === 'type') {
                    // Compare F2P vs Members
                    // We ignore the 'is_f2p' filter from the dropdown if it's set, as we are splitting by it.
                    // We keep world/location filters if set.
                    
                    const [f2pData, memData] = await Promise.all([
                        fetchHistory({ start: startISO, end: endISO, unit, step, agg, world_id: worldId, location_id: locationId, is_f2p: 1 }),
                        fetchHistory({ start: startISO, end: endISO, unit, step, agg, world_id: worldId, location_id: locationId, is_f2p: 0 })
                    ]);

                    datasets = [
                        {
                            label: 'Free-to-Play',
                            data: f2pData.map(p => ({ x: new Date(p.timestamp), y: p.count })),
                            borderColor: '#aaaaaa', // Silver/Grey for F2P
                            backgroundColor: 'rgba(170, 170, 170, 0.1)'
                        },
                        {
                            label: 'Members',
                            data: memData.map(p => ({ x: new Date(p.timestamp), y: p.count })),
                            borderColor: '#ffff00', // Gold for Members
                            backgroundColor: 'rgba(255, 255, 0, 0.1)'
                        }
                    ];
                } else if (compareMode === 'location') {
                    // Compare Regions
                    // We ignore 'location_id' filter.
                    // We keep world/f2p filters if set (though world implies location, so usually world filter should be empty)
                    
                    // Use globalMetadata.locations to get list
                    const locs = globalMetadata.locations;
                    const requests = locs.map(loc => 
                        fetchHistory({ start: startISO, end: endISO, unit, step, agg, world_id: worldId, is_f2p: isF2p, location_id: loc.id })
                            .then(data => ({ loc, data }))
                    );
                    
                    const results = await Promise.all(requests);
                    
                    datasets = results.map((res, idx) => ({
                        label: res.loc.name,
                        data: res.data.map(p => ({ x: new Date(p.timestamp), y: p.count })),
                        borderColor: colors[idx % colors.length],
                        backgroundColor: null // No fill for many lines to avoid clutter
                    }));
                } else if (compareMode === 'worlds') {
                    // Compare All Worlds (Filtered by other selections)
                    // We iterate all known worlds and fetch data for each, respecting location/f2p filters.
                    // If a world doesn't match the filters, the API returns empty data, and we skip it.
                    
                    const worlds = globalMetadata.worlds;
                    // Create a promise for each world
                    const requests = worlds.map(w => 
                        fetchHistory({ 
                            start: startISO, end: endISO, unit, step, agg, 
                            world_id: w, 
                            location_id: locationId, 
                            is_f2p: isF2p 
                        })
                        .then(data => ({ world: w, data }))
                        .catch(e => null)
                    );
                    
                    const results = await Promise.all(requests);
                    
                    datasets = results
                        .filter(r => r && r.data && r.data.length > 0)
                        .map((res, idx) => ({
                            label: `World ${parseInt(res.world) + 300}`,
                            data: res.data.map(p => ({ x: new Date(p.timestamp), y: p.count })),
                            borderColor: colors[idx % colors.length],
                            backgroundColor: null,
                            borderWidth: 1, // Thinner lines for mass comparison
                            pointRadius: 0
                        }));
                }

                buildChart(datasets, { unit, step });
            } catch (err) {
                console.error('Update failed:', err);
                showChartError(err.message || 'Failed to load data');
            } finally {
                hideSpinner();
                setControlsEnabled(true);
            }
        }

        // Preset range buttons
        function setPresetHours(hours) {
            const end = new Date();
            const start = new Date(end.getTime() - hours*60*60*1000);
            document.getElementById('startInput').value = toLocalInputISO(start);
            document.getElementById('endInput').value = toLocalInputISO(end);
        }

        // Preset for months (handles month rollovers)
        function setPresetMonths(months) {
            const end = new Date();
            const start = new Date(end.getFullYear(), end.getMonth() - months, end.getDate(), end.getHours(), end.getMinutes(), end.getSeconds());
            document.getElementById('startInput').value = toLocalInputISO(start);
            document.getElementById('endInput').value = toLocalInputISO(end);
        }

        function setPresetYears(years) {
            const end = new Date();
            const start = new Date(end.getFullYear() - years, end.getMonth(), end.getDate(), end.getHours(), end.getMinutes(), end.getSeconds());
            document.getElementById('startInput').value = toLocalInputISO(start);
            document.getElementById('endInput').value = toLocalInputISO(end);
        }

        function applyPreset(v) {
            switch (v) {
                case '3h': setPresetHours(3); break;
                case '6h': setPresetHours(6); break;
                case '12h': setPresetHours(12); break;
                case '24h': setPresetHours(24); break;
                case '7d': setPresetHours(24*7); break;
                case '30d': setPresetHours(24*30); break;
                case '6m': setPresetMonths(6); break;
                case '1y': setPresetYears(1); break;
                case '5y': setPresetYears(5); break;
                case '10y': setPresetYears(10); break;
            }
            updateGranularityAvailability();
            updateFromInputs();
        }

        // Initialize page: set default inputs and render
        async function initializePage() {
            // Default to last 7d with hour granularity
            setPresetHours(24 * 7);
            document.getElementById('granularitySelect').value = 'hour';
            // Ensure minute options availability reflects the default range
            updateGranularityAvailability();

            // Wire up controls
            document.getElementById('applyRangeBtn').addEventListener('click', updateFromInputs);
            const presetEl = document.getElementById('presetSelect');
            if (presetEl) {
                // set default preset to Last 7d
                presetEl.value = '7d';
                presetEl.addEventListener('change', () => {
                    applyPreset(presetEl.value);
                });
            }
            document.getElementById('granularitySelect').addEventListener('change', updateFromInputs);
            document.getElementById('aggregationSelect').addEventListener('change', updateFromInputs);
            
            // When a specific world is selected, reset other filters as they don't apply
            document.getElementById('worldSelect').addEventListener('change', function() {
                if (this.value) {
                    document.getElementById('locationSelect').value = "";
                    document.getElementById('f2pSelect').value = "";
                    document.getElementById('compareSelect').value = "none";
                }
                updateFromInputs();
            });

            document.getElementById('locationSelect').addEventListener('change', updateFromInputs);
            document.getElementById('f2pSelect').addEventListener('change', updateFromInputs);
            document.getElementById('compareSelect').addEventListener('change', updateFromInputs);
            document.getElementById('resetZoomBtn').addEventListener('click', () => { if (populationChart) populationChart.resetZoom(); });
            
            // Recalculate availability when user edits start/end inputs
            const onInputChange = () => {
                updateGranularityAvailability();
                if (presetEl) presetEl.value = 'custom';
            };
            document.getElementById('startInput').addEventListener('change', onInputChange);
            document.getElementById('endInput').addEventListener('change', onInputChange);

            // Initial fetch and render
            await fetchMetadata();
            await fetchLatest();
            await updateFromInputs();

            // Auto-refresh every 2 minutes
            setInterval(async () => {
                await fetchLatest();
                // If we are on a preset (not custom), refresh the chart range to keep it "live"
                if (presetEl && presetEl.value !== 'custom') {
                    applyPreset(presetEl.value);
                }
            }, 2 * 60 * 1000);
        }

        // Run initialize on page load
        window.addEventListener('DOMContentLoaded', initializePage);

        // Easter Egg: Dragon Scimitar Cursor Toggle
        document.addEventListener('DOMContentLoaded', function() {
            const toggle = document.getElementById('scimitar-toggle');
            if (toggle) {
                toggle.addEventListener('click', function() {
                    document.body.classList.toggle('dragon-cursor');
                });
            }
        });

        // Easter Egg: Gnome Child Scroll
        let scrollCount = 0;
        const SCROLL_THRESHOLD = 50; // Number of scroll events to trigger

        function handleWheel(e) {
            const gnome = document.getElementById('gnome-child');
            // Check if we are at the bottom (or page is not scrollable)
            const isAtBottom = (window.innerHeight + window.scrollY) >= document.documentElement.scrollHeight - 10;
            
            if (isAtBottom) {
                if (e.deltaY > 0) { // Scrolling down while at bottom
                    scrollCount++;
                    if (scrollCount > SCROLL_THRESHOLD) {
                        gnome.classList.add('peeking');
                    }
                } else { // Scrolling up
                    scrollCount = 0;
                    gnome.classList.remove('peeking');
                }
            } else {
                scrollCount = 0;
                gnome.classList.remove('peeking');
            }
        }
        
        // Reset if user scrolls away using scrollbar
        window.addEventListener('scroll', () => {
            const gnome = document.getElementById('gnome-child');
            const isAtBottom = (window.innerHeight + window.scrollY) >= document.documentElement.scrollHeight - 10;
            if (!isAtBottom) {
                scrollCount = 0;
                touchScrollDistance = 0;
                gnome.classList.remove('peeking');
            }
        });

        // Listen for wheel events to catch scrolling even when page doesn't move
        window.addEventListener('wheel', handleWheel);

        // Mobile Touch Support
        let touchStartY = 0;
        let touchScrollDistance = 0;
        const TOUCH_THRESHOLD = 400; // Pixels

        window.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            const gnome = document.getElementById('gnome-child');
            const currentY = e.touches[0].clientY;
            const deltaY = touchStartY - currentY;
            touchStartY = currentY;

            const isAtBottom = (window.innerHeight + window.scrollY) >= document.documentElement.scrollHeight - 10;

            if (isAtBottom) {
                if (deltaY > 0) {
                    touchScrollDistance += deltaY;
                    if (touchScrollDistance > TOUCH_THRESHOLD) {
                        gnome.classList.add('peeking');
                    }
                } else if (deltaY < -2) { // Small buffer for jitter
                    touchScrollDistance = 0;
                    gnome.classList.remove('peeking');
                }
            } else {
                touchScrollDistance = 0;
                gnome.classList.remove('peeking');
            }
        }, { passive: true }); 

        // Easter Egg: Konami Code
        const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        let konamiIndex = 0;

        document.addEventListener('keydown', (e) => {
            if (e.key === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    const el = document.getElementById('connection-lost');
                    el.style.display = 'block';
                    setTimeout(() => { el.style.display = 'none'; }, 5000);
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });
    </script>

    <footer class="site-footer">
        <div class="container">
            <a href="https://github.com/UsefulEndymion/osrsplayercount" target="_blank" rel="noopener noreferrer" class="github-link">
                View/Contribute on GitHub
                <span class="tooltip">beware the code is very <b>slop</b>-y</span>
            </a>
            <img id="scimitar-toggle" src="https://oldschool.runescape.wiki/images/Dragon_scimitar.png?36084" alt="Toggle Dragon Scimitar Cursor" title="Toggle Dragon Scimitar Cursor">
        </div>
    </footer>

    <script>
        // Easter Egg: Play sound after 20 minutes
        setTimeout(() => {
            const audio = new Audio('https://oldschool.runescape.wiki/images/Armadyl_Eye_sound.ogg?37997');
            audio.volume = 0.5;
            audio.play().catch(e => console.error("Audio play failed (autoplay policy?):", e));
        }, 60 * 60 * 1000);
    </script>

</body>
</html>